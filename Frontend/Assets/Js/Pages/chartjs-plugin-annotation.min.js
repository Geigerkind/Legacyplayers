var altItr = true;
!function e(t, n, a) { function i(l, r) { if (!n[l]) { if (!t[l]) { var s = "function" == typeof require && require; if (!r && s) return s(l, !0); if (o) return o(l, !0); var c = new Error("Cannot find module '" + l + "'"); throw c.code = "MODULE_NOT_FOUND", c } var u = n[l] = { exports: {} }; t[l][0].call(u.exports, function (e) { var n = t[l][1][e]; return i(n ? n : e) }, u, u.exports, e, t, n, a) } return n[l].exports } for (var o = "function" == typeof require && require, l = 0; l < a.length; l++)i(a[l]); return i }({ 1: [function (e, t, n) { }, {}], 2: [function (e, t, n) { t.exports = function (t) { function n(e) { o.decorate(e, "afterDataLimits", function (e, t) { e && e(t), o.adjustScaleRange(t) }) } function a(e) { return function (t, n) { var a = t.annotation.options.drawTime; o.elements(t).filter(function (t) { return e === (t.options.drawTime || a) }).forEach(function (e) { e.transition(n).draw() }) } } var i = t.helpers, o = e("./helpers.js")(t), l = e("./events.js")(t), r = t.Annotation.types; return { beforeInit: function (e) { var t = e.options, a = e.annotation = { elements: {}, options: o.initConfig(t.annotation || {}), onDestroy: [], firstRun: !0, supported: !1 }; e.ensureScalesHaveIDs(), t.scales && (a.supported = !0, i.each(t.scales.xAxes, n), i.each(t.scales.yAxes, n)) }, beforeUpdate: function (e) { var t = e.annotation; if (t.supported) { t.firstRun ? t.firstRun = !1 : t.options = o.initConfig(e.options.annotation || {}); var n = []; t.options.annotations.forEach(function (a) { var i = a.id || o.objectId(); if (!t.elements[i] && r[a.type]) { var l = r[a.type], s = new l({ id: i, options: a, chartInstance: e }); s.initialize(), t.elements[i] = s, a.id = i, n.push(i) } else t.elements[i] && n.push(i) }), Object.keys(t.elements).forEach(function (e) { -1 === n.indexOf(e) && (t.elements[e].destroy(), delete t.elements[e]) }) } }, afterScaleUpdate: function (e) { o.elements(e).forEach(function (e) { e.configure() }) }, beforeDatasetsDraw: a("beforeDatasetsDraw"), afterDatasetsDraw: a("afterDatasetsDraw"), afterDraw: a("afterDraw"), afterInit: function (e) { var t = e.annotation.options.events; if (i.isArray(t) && t.length > 0) { var n = e.chart.canvas, a = l.dispatcher.bind(e); l.collapseHoverEvents(t).forEach(function (t) { i.addEvent(n, t, a), e.annotation.onDestroy.push(function () { i.removeEvent(n, t, a) }) }) } }, destroy: function (e) { for (var t = e.annotation.onDestroy; t.length > 0;)t.pop()() } } } }, { "./events.js": 4, "./helpers.js": 5 }], 3: [function (e, t, n) { t.exports = function (e) { var t = e.helpers, n = e.Element.extend({ initialize: function () { this.hidden = !1, this.hovering = !1, this._model = t.clone(this._model) || {}, this.setDataLimits() }, destroy: function () { }, setDataLimits: function () { }, configure: function () { }, inRange: function () { }, getCenterPoint: function () { }, getWidth: function () { }, getHeight: function () { }, getArea: function () { }, draw: function () { } }); return n } }, {}], 4: [function (e, t, n) { t.exports = function (t) { function n(e) { var t = !1, n = e.filter(function (e) { switch (e) { case "mouseenter": case "mouseover": case "mouseout": case "mouseleave": return t = !0, !1; default: return !0 } }); return t && -1 === n.indexOf("mousemove") && n.push("mousemove"), n } function a(e) { var t = this.annotation, a = o.elements(this), l = i.getRelativePosition(e, this.chart), r = o.getNearestItems(a, l), s = n(t.options.events), c = t.options.dblClickSpeed, u = [], d = o.getEventHandlerName(e.type), f = (r || {}).options; if ("mousemove" === e.type && (r && !r.hovering ? ["mouseenter", "mouseover"].forEach(function (t) { var n = o.getEventHandlerName(t), a = o.createMouseEvent(t, e); r.hovering = !0, "function" == typeof f[n] && u.push([f[n], a, r]) }) : r || a.forEach(function (t) { if (t.hovering) { t.hovering = !1; var n = t.options;["mouseout", "mouseleave"].forEach(function (a) { var i = o.getEventHandlerName(a), l = o.createMouseEvent(a, e); "function" == typeof n[i] && u.push([n[i], l, t]) }) } })), r && s.indexOf("dblclick") > -1 && "function" == typeof f.onDblclick) { if ("click" === e.type && "function" == typeof f.onClick) return clearTimeout(r.clickTimeout), r.clickTimeout = setTimeout(function () { delete r.clickTimeout, f.onClick.call(r, e) }, c), e.stopImmediatePropagation(), void e.preventDefault(); "dblclick" === e.type && r.clickTimeout && (clearTimeout(r.clickTimeout), delete r.clickTimeout) } r && "function" == typeof f[d] && 0 === u.length && u.push([f[d], e, r]), u.length > 0 && (e.stopImmediatePropagation(), e.preventDefault(), u.forEach(function (e) { e[0].call(e[2], e[1]) })) } var i = t.helpers, o = e("./helpers.js")(t); return { dispatcher: a, collapseHoverEvents: n } } }, { "./helpers.js": 5 }], 5: [function (e, t, n) { function a() { } function i(e) { var t = e.annotation.elements; return Object.keys(t).map(function (e) { return t[e] }) } function o() { return Math.random().toString(36).substr(2, 6) } function l(e) { return null === e || "undefined" == typeof e ? !1 : "number" == typeof e ? isFinite(e) : !!e } function r(e, t, n) { var a = "$"; e[a + t] || (e[t] ? (e[a + t] = e[t].bind(e), e[t] = function () { var i = [e[a + t]].concat(Array.prototype.slice.call(arguments)); return n.apply(e, i) }) : e[t] = function () { var t = [void 0].concat(Array.prototype.slice.call(arguments)); return n.apply(e, t) }) } function s(e, t) { e.forEach(function (e) { (t ? e[t] : e)() }) } function c(e) { return "on" + e[0].toUpperCase() + e.substring(1) } function u(e, t) { try { return new MouseEvent(e, t) } catch (n) { try { var a = document.createEvent("MouseEvent"); return a.initMouseEvent(e, t.canBubble, t.cancelable, t.view, t.detail, t.screenX, t.screenY, t.clientX, t.clientY, t.ctrlKey, t.altKey, t.shiftKey, t.metaKey, t.button, t.relatedTarget), a } catch (i) { var o = document.createEvent("Event"); return o.initEvent(e, t.canBubble, t.cancelable), o } } } t.exports = function (e) { function t(t) { return t = b.configMerge(e.Annotation.defaults, t), b.isArray(t.annotations) && t.annotations.forEach(function (t) { t.label = b.configMerge(e.Annotation.labelDefaults, t.label) }), t } function n(e, t, n, a) { var i = t.filter(function (t) { return !!t._model.ranges[e] }).map(function (t) { return t._model.ranges[e] }), o = i.map(function (e) { return Number(e.min) }).reduce(function (e, t) { return isFinite(t) && !isNaN(t) && e > t ? t : e }, n), l = i.map(function (e) { return Number(e.max) }).reduce(function (e, t) { return isFinite(t) && !isNaN(t) && t > e ? t : e }, a); return { min: o, max: l } } function d(e) { var t = n(e.id, i(e.chart), e.min, e.max); "undefined" == typeof e.options.ticks.min && "undefined" == typeof e.options.ticks.suggestedMin && (e.min = t.min), "undefined" == typeof e.options.ticks.max && "undefined" == typeof e.options.ticks.suggestedMax && (e.max = t.max), e.handleTickRangeOptions && e.handleTickRangeOptions() } function f(e, t) { var n = Number.POSITIVE_INFINITY; return e.filter(function (e) { return e.inRange(t.x, t.y) }).reduce(function (e, a) { var i = a.getCenterPoint(), o = b.distanceBetweenPoints(t, i); return n > o ? (e = [a], n = o) : o === n && e.push(a), e }, []).sort(function (e, t) { var n = e.getArea(), a = t.getArea(); return n > a || a > n ? n - a : e._index - t._index }).slice(0, 1)[0] } var b = e.helpers; return { initConfig: t, elements: i, callEach: s, noop: a, objectId: o, isValid: l, decorate: r, adjustScaleRange: d, getNearestItems: f, getEventHandlerName: c, createMouseEvent: u } } }, {}], 6: [function (e, t, n) { var a = e("chart.js"); a = "function" == typeof a ? a : window.Chart, a.Annotation = a.Annotation || {}, a.Annotation.drawTimeOptions = { afterDraw: "afterDraw", afterDatasetsDraw: "afterDatasetsDraw", beforeDatasetsDraw: "beforeDatasetsDraw" }, a.Annotation.defaults = { drawTime: "afterDatasetsDraw", dblClickSpeed: 350, events: [], annotations: [] }, a.Annotation.labelDefaults = { backgroundColor: "rgba(0,0,0,0.8)", fontFamily: a.defaults.global.defaultFontFamily, fontSize: a.defaults.global.defaultFontSize, fontStyle: "bold", fontColor: "#fff", xPadding: 6, yPadding: 6, cornerRadius: 6, position: "center", xAdjust: 0, yAdjust: 0, enabled: !1, content: null }, a.Annotation.Element = e("./element.js")(a), a.Annotation.types = { line: e("./types/line.js")(a), box: e("./types/box.js")(a) }; var i = e("./annotation.js")(a); t.exports = i, a.pluginService.register(i) }, { "./annotation.js": 2, "./element.js": 3, "./types/box.js": 7, "./types/line.js": 8, "chart.js": 1 }], 7: [function (e, t, n) { t.exports = function (t) { var n = t.helpers, a = e("../helpers.js")(t), i = t.Annotation.Element.extend({ setDataLimits: function () { var e = this._model, t = this.options, n = this.chartInstance, i = n.scales[t.xScaleID], o = n.scales[t.yScaleID], l = n.chartArea; if (e.ranges = {}, l) { var r = 0, s = 0; i && (r = a.isValid(t.xMin) ? t.xMin : i.getPixelForValue(l.left), s = a.isValid(t.xMax) ? t.xMax : i.getPixelForValue(l.right), e.ranges[t.xScaleID] = { min: Math.min(r, s), max: Math.max(r, s) }), o && (r = a.isValid(t.yMin) ? t.yMin : o.getPixelForValue(l.bottom), s = a.isValid(t.yMax) ? t.yMax : o.getPixelForValue(l.top), e.ranges[t.yScaleID] = { min: Math.min(r, s), max: Math.max(r, s) }) } }, configure: function () { var e = this._model, t = this.options, i = this.chartInstance, o = i.chart.ctx, l = i.scales[t.xScaleID], r = i.scales[t.yScaleID], s = i.chartArea; e.clip = { x1: s.left, x2: s.right, y1: s.top, y2: s.bottom }; var c, u, d = s.left, f = s.top, b = s.right, h = s.bottom; l && (c = a.isValid(t.xMin) ? l.getPixelForValue(t.xMin) : s.left, u = a.isValid(t.xMax) ? l.getPixelForValue(t.xMax) : s.right, d = Math.min(c, u), b = Math.max(c, u)), r && (c = a.isValid(t.yMin) ? r.getPixelForValue(t.yMin) : s.bottom, u = a.isValid(t.yMax) ? r.getPixelForValue(t.yMax) : s.top, f = Math.min(c, u), h = Math.max(c, u)), e.labelBackgroundColor = t.label.backgroundColor, e.labelFontFamily = t.label.fontFamily, e.labelFontSize = t.label.fontSize, e.labelFontStyle = t.label.fontStyle, e.labelFontColor = t.label.fontColor, e.labelXPadding = t.label.xPadding, e.labelYPadding = t.label.yPadding, e.labelCornerRadius = t.label.cornerRadius, e.labelPosition = t.label.position, e.labelXAdjust = t.label.xAdjust, e.labelYAdjust = t.label.yAdjust, e.labelEnabled = t.label.enabled, e.labelContent = t.label.content, o.font = n.fontString(e.labelFontSize, e.labelFontStyle, e.labelFontFamily); var p = o.measureText(e.labelContent).width, g = o.measureText("M").width, m = { x: (d + b) / 2, y: (f + h) / 2 }; e.labelX = m.x - e.labelXPadding, e.labelY = m.y - e.labelYPadding, e.labelWidth = p + 2 * e.labelXPadding, e.labelHeight = g + 2 * e.labelYPadding, e.left = d, e.top = f, e.right = b, e.bottom = h, e.borderColor = t.borderColor, e.borderWidth = t.borderWidth, e.backgroundColor = t.backgroundColor }, inRange: function (e, t) { var n = this._model; return n && e >= n.left && e <= n.right && t >= n.top && t <= n.bottom }, getCenterPoint: function () { var e = this._model; return { x: (e.right + e.left) / 2, y: (e.bottom + e.top) / 2 } }, getWidth: function () { var e = this._model; return Math.abs(e.right - e.left) }, getHeight: function () { var e = this._model; return Math.abs(e.bottom - e.top) }, getArea: function () { return this.getWidth() * this.getHeight() }, draw: function () { var e = this._view, t = this.chartInstance.chart.ctx; t.save(), t.beginPath(), t.rect(e.clip.x1, e.clip.y1, e.clip.x2 - e.clip.x1, e.clip.y2 - e.clip.y1), t.clip(), t.lineWidth = e.borderWidth, t.strokeStyle = e.borderColor, t.fillStyle = e.backgroundColor; var a = e.right - e.left, i = e.bottom - e.top; t.setLineDash([4, 4]); t.lineDashOffset = 10; if (t.fillRect(e.left, e.top - 25, a, i + 50), t.strokeRect(e.left, e.top - 25, a, i + 50), e.labelEnabled && e.labelContent) { t.font = n.fontString(14, "", e.labelFontFamily), t.fillStyle = e.labelFontColor, t.textAlign = "center", t.textBaseline = "middle"; var o = e.labelContent.split(" "), l = i / o.length, r = 2.5; altItr = altItr ? false : true; o.forEach(function (n) { t.fillText(n, e.labelX + 6, e.top + r * 18 + (altItr ? 100 : 0)), ++r }) } t.restore() } }); return i } }, { "../helpers.js": 5 }], 8: [function (e, t, n) { t.exports = function (t) { function n(e) { var t = (e.x2 - e.x1) / (e.y2 - e.y1), n = e.x1 || 0; this.m = t, this.b = n, this.getX = function (a) { return t * (a - e.y1) + n }, this.getY = function (a) { return (a - n) / t + e.y1 }, this.intersects = function (e, t, n) { n = n || .001; var a = this.getY(e), i = this.getX(t); return (!isFinite(a) || Math.abs(t - a) < n) && (!isFinite(i) || Math.abs(e - i) < n) } } function a(e, t, n, a, i) { var o = e.line, s = {}, c = 0, u = 0; switch (!0) { case e.mode == r && "top" == e.labelPosition: u = i + e.labelYAdjust, c = t / 2 + e.labelXAdjust, s.y = e.y1 + u, s.x = (isFinite(o.m) ? o.getX(s.y) : e.x1) - c; break; case e.mode == r && "bottom" == e.labelPosition: u = n + i + e.labelYAdjust, c = t / 2 + e.labelXAdjust, s.y = e.y2 - u, s.x = (isFinite(o.m) ? o.getX(s.y) : e.x1) - c; break; case e.mode == l && "left" == e.labelPosition: c = a + e.labelXAdjust, u = -(n / 2) + e.labelYAdjust, s.x = e.x1 + c, s.y = o.getY(s.x) + u; break; case e.mode == l && "right" == e.labelPosition: c = t + a + e.labelXAdjust, u = -(n / 2) + e.labelYAdjust, s.x = e.x2 - c, s.y = o.getY(s.x) + u; break; default: s.x = (e.x1 + e.x2 - t) / 2 + e.labelXAdjust, s.y = (e.y1 + e.y2 - n) / 2 + e.labelYAdjust }return s } var i = t.helpers, o = e("../helpers.js")(t), l = "horizontal", r = "vertical", s = t.Annotation.Element.extend({ setDataLimits: function () { var e = this._model, t = this.options; e.ranges = {}, e.ranges[t.scaleID] = { min: t.value, max: t.endValue || t.value } }, configure: function () { var e, t, r = this._model, s = this.options, c = this.chartInstance, u = c.chart.ctx, d = c.scales[s.scaleID]; if (d && (e = o.isValid(s.value) ? d.getPixelForValue(s.value) : NaN, t = o.isValid(s.endValue) ? d.getPixelForValue(s.endValue) : e), !isNaN(e)) { var f = c.chartArea; r.clip = { x1: f.left, x2: f.right, y1: f.top, y2: f.bottom }, this.options.mode == l ? (r.x1 = f.left, r.x2 = f.right, r.y1 = e, r.y2 = t) : (r.y1 = f.top, r.y2 = f.bottom, r.x1 = e, r.x2 = t), r.line = new n(r), r.mode = s.mode, r.labelBackgroundColor = s.label.backgroundColor, r.labelFontFamily = s.label.fontFamily, r.labelFontSize = s.label.fontSize, r.labelFontStyle = s.label.fontStyle, r.labelFontColor = s.label.fontColor, r.labelXPadding = s.label.xPadding, r.labelYPadding = s.label.yPadding, r.labelCornerRadius = s.label.cornerRadius, r.labelPosition = s.label.position, r.labelXAdjust = s.label.xAdjust, r.labelYAdjust = s.label.yAdjust, r.labelEnabled = s.label.enabled, r.labelContent = s.label.content, u.font = i.fontString(r.labelFontSize, r.labelFontStyle, r.labelFontFamily); var b = u.measureText(r.labelContent).width, h = u.measureText("M").width, p = a(r, b, h, r.labelXPadding, r.labelYPadding); r.labelX = p.x - r.labelXPadding, r.labelY = p.y - r.labelYPadding, r.labelWidth = b + 2 * r.labelXPadding, r.labelHeight = h + 2 * r.labelYPadding, r.borderColor = s.borderColor, r.borderWidth = s.borderWidth, r.borderDash = s.borderDash || [], r.borderDashOffset = s.borderDashOffset || 0 } }, inRange: function (e, t) { var n = this._model; return n.line && n.line.intersects(e, t, this.getHeight()) || n.labelEnabled && n.labelContent && e >= n.labelX && e <= n.labelX + n.labelWidth && t >= n.labelY && t <= n.labelY + n.labelHeight }, getCenterPoint: function () { return { x: (this._model.x2 + this._model.x1) / 2, y: (this._model.y2 + this._model.y1) / 2 } }, getWidth: function () { return Math.abs(this._model.right - this._model.left) }, getHeight: function () { return this._model.borderWidth || 1 }, getArea: function () { return Math.sqrt(Math.pow(this.getWidth(), 2) + Math.pow(this.getHeight(), 2)) }, draw: function () { var e = this._view, t = this.chartInstance.chart.ctx; e.clip && (t.save(), t.beginPath(), t.rect(e.clip.x1, e.clip.y1, e.clip.x2 - e.clip.x1, e.clip.y2 - e.clip.y1), t.clip(), t.lineWidth = e.borderWidth, t.strokeStyle = e.borderColor, t.setLineDash && t.setLineDash(e.borderDash), t.lineDashOffset = e.borderDashOffset, t.beginPath(), t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.stroke(), e.labelEnabled && e.labelContent && (t.beginPath(), t.rect(e.clip.x1, e.clip.y1, e.clip.x2 - e.clip.x1, e.clip.y2 - e.clip.y1), t.clip(), t.fillStyle = e.labelBackgroundColor, i.drawRoundedRectangle(t, e.labelX, e.labelY, e.labelWidth, e.labelHeight, e.labelCornerRadius), t.fill(), t.font = i.fontString(e.labelFontSize, e.labelFontStyle, e.labelFontFamily), t.fillStyle = e.labelFontColor, t.textAlign = "center", t.textBaseline = "middle", t.fillText(e.labelContent, e.labelX + e.labelWidth / 2, e.labelY + e.labelHeight / 2)), t.restore()) } }); return s } }, { "../helpers.js": 5 }] }, {}, [6]);